<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <title>English Drill: Hints & Reset</title>
        <style>
            /* --- 共通変数定義 --- */
            :root {
                --text-main: #333333;
                --text-white: #ffffff;
                --success-color: #28a745;
                --error-color: #dc3545;
                --bg-color: #f9f9f9;
                --card-bg: #ffffff;
                --stamp-color: #d32f2f;
                /* モード別カラー */
                --color-select-bg: #E1F5FE; --color-select-border: #4FC3F7; --color-select-dark: #0288D1;
                --color-sort-bg: #FFF3E0;   --color-sort-border: #FFB74D;   --color-sort-dark: #F57C00;
                --color-input-bg: #E8F5E9;  --color-input-border: #81C784;  --color-input-dark: #388E3C;
                --color-full-bg: #FCE4EC;   --color-full-border: #F06292;   --color-full-dark: #C2185B;
            }
            
            body {
                font-family: "Helvetica Neue", Arial, sans-serif;
                margin: 0;
                padding: 20px;
                background-color: var(--bg-color);
                color: var(--text-main);
                -webkit-text-size-adjust: 100%;
                overflow-x: hidden;
            }
            
            .container {
                max-width: 900px;
                margin: 0 auto;
                background: var(--card-bg);
                border-radius: 15px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.08);
                padding: 30px;
                min-height: 60vh;
                display: flex;
                flex-direction: column;
                position: relative;
                z-index: 1;
            }
            
            /* --- メニュー画面 --- */
            #menu-screen { text-align: center; display: flex; flex-direction: column; gap: 20px; }
            .menu-title { font-size: 2rem; color: #555; margin-bottom: 10px; }
            .menu-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; padding: 10px; }
            .menu-btn-wrapper { position: relative; }
            .menu-btn { width: 100%; height: 100%; padding: 25px 10px; font-size: 1.2rem; border: 2px solid transparent; border-radius: 15px; cursor: pointer; transition: all 0.2s; font-weight: bold; color: var(--text-main); display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
            .menu-btn:hover { transform: translateY(-3px); box-shadow: 0 5px 10px rgba(0,0,0,0.1); }
            .menu-sub { font-size: 0.8rem; font-weight: normal; margin-top: 5px; opacity: 0.8; }
            .btn-select { background-color: var(--color-select-bg); border-color: var(--color-select-border); }
            .btn-select:hover { background-color: var(--color-select-border); color: var(--text-white); }
            .btn-sort { background-color: var(--color-sort-bg); border-color: var(--color-sort-border); }
            .btn-sort:hover { background-color: var(--color-sort-border); color: var(--text-white); }
            .btn-input { background-color: var(--color-input-bg); border-color: var(--color-input-border); }
            .btn-input:hover { background-color: var(--color-input-border); color: var(--text-white); }
            .btn-full { background-color: var(--color-full-bg); border-color: var(--color-full-border); }
            .btn-full:hover { background-color: var(--color-full-border); color: var(--text-white); }
            
            /* ★バッジサイズ調整: 大きくしました */
            .gj-badge { 
                position: absolute; 
                top: -15px; /* 位置調整 */
                right: -15px; /* 位置調整 */
                background: var(--stamp-color); 
                color: white; 
                width: 60px; /* 45px -> 60px */
                height: 60px; /* 45px -> 60px */
                border-radius: 50%; 
                display: flex; 
                align-items: center; 
                justify-content: center; 
                font-weight: bold; 
                font-size: 1.2rem; /* 0.9rem -> 1.2rem */
                box-shadow: 0 2px 5px rgba(0,0,0,0.3); 
                border: 2px solid white; 
                transform: rotate(15deg) scale(0); 
                transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
                z-index: 10; 
            }
            .gj-badge.earned { transform: rotate(15deg) scale(1); }
            
            /* --- ゲーム画面 --- */
            #game-screen, #result-screen { display: none; flex-direction: column; height: 100%; flex-grow: 1; }
            header { text-align: center; margin-bottom: 20px; border-bottom: 2px solid #f0f0f0; padding-bottom: 15px; }
            .mode-badge { display: inline-block; color: white; padding: 6px 15px; border-radius: 20px; font-weight: bold; margin-bottom: 5px; font-size: 1.1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
            .theme-select { background-color: var(--color-select-dark); }
            .theme-sort { background-color: var(--color-sort-dark); }
            .theme-input { background-color: var(--color-input-dark); }
            .theme-full { background-color: var(--color-full-dark); }
            .progress-bar-bg { width: 100%; height: 10px; background: #eee; border-radius: 5px; margin-top: 10px; overflow: hidden; }
            .progress-bar-fill { height: 100%; background: var(--success-color); width: 0%; transition: width 0.3s ease; }
            .back-btn { background: #999; color: white; border: none; padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; cursor: pointer; transition: background 0.2s; }
            .back-btn:hover { background: #777; }
            
            /* 問題表示エリア (Flexにしてリセットボタンを横に置けるようにする) */
            .question-area { 
                display: flex; 
                justify-content: center; 
                align-items: center; 
                gap: 15px; 
                margin-bottom: 30px; 
                min-height: 50px;
                flex-wrap: wrap;
            }
            .jp-text { font-size: 1.6rem; font-weight: bold; color: #444; margin: 0; }
            
            /* リセットボタン */
            .btn-reset {
                font-size: 0.9rem;
                padding: 5px 12px;
                background-color: #90A4AE;
                color: white;
                border: none;
                border-radius: 15px;
                cursor: pointer;
                display: none; /* デフォルト非表示 */
            }
            .btn-reset:hover { background-color: #607D8B; }
            
            .interaction-area { background: #fff; border: 2px dashed #ddd; border-radius: 12px; padding: 20px; min-height: 80px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px; margin-bottom: 20px; font-size: 1.4rem; line-height: 2.2rem; transition: border-color 0.3s; position: relative; z-index: 2; }
            .theme-border-select { border-color: var(--color-select-border); background-color: #fafdff; }
            .theme-border-sort { border-color: var(--color-sort-border); background-color: #fffaf5; }
            .theme-border-input { border-color: var(--color-input-border); background-color: #f5fbf6; }
            .theme-border-full { border-color: var(--color-full-border); background-color: #fff5f8; }
            .word-chip { padding: 10px 18px; font-size: 1.2rem; background: #fff; border: 2px solid #ccc; border-radius: 25px; cursor: pointer; user-select: none; touch-action: manipulation; box-shadow: 0 2px 0px rgba(0,0,0,0.1); transition: transform 0.1s, box-shadow 0.1s; }
            .word-chip:active { transform: translateY(2px); box-shadow: none; }
            .word-chip.selected { opacity: 0.3; pointer-events: none; border-style: dashed; }
            .options-area { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; margin-top: 10px; z-index: 2; }
            input[type="text"] { font-size: 1.4rem; padding: 5px 10px; border: 2px solid #ddd; border-radius: 8px; text-align: center; color: var(--text-main); }
            input[type="text"]:focus { outline: none; border-color: #aaa; }
            #full-input { width: 90%; max-width: 700px; }
            
            /* 入力欄とエラーマークのラッパー */
            .gap-wrapper { display: inline-flex; align-items: center; margin: 0 4px; position: relative; }
            .gap-input { min-width: 40px; border: none; border-bottom: 3px solid #888; background: transparent; color: var(--color-select-dark); font-weight: bold; text-align: center; padding: 0 5px; height: 1.8rem; }
            
            /* エラーマーク (!) */
            .error-mark {
                color: var(--error-color);
                font-weight: bold;
                font-size: 1.2rem;
                margin-left: 3px;
                animation: shake 0.3s ease-in-out;
            }
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-2px); }
                75% { transform: translateX(2px); }
            }
            
            .action-area { display:flex; justify-content:center; align-items:center; gap:10px; margin-top: auto; height: 70px; z-index: 2; }
            .btn-check, .btn-next, .btn-hint { font-size: 1.2rem; padding: 12px 30px; border: none; border-radius: 50px; cursor: pointer; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.15); font-weight: bold; }
            .btn-check { background: var(--text-main); }
            .btn-next { background: var(--success-color); display: none; }
            
            /* ヒントボタン */
            .btn-hint {
                background-color: #FFCA28; /* アンバー */
                color: #333;
                display: none; /* JSで制御 */
            }
            .btn-hint:hover { background-color: #FFD54F; }
            
            .feedback-msg { font-size: 1.5rem; font-weight: bold; height: 40px; margin-bottom: 10px; text-align: center; z-index: 2; }
            .correct-text { color: var(--success-color); }
            .wrong-text { color: var(--error-color); }
            #result-screen { align-items: center; justify-content: center; text-align: center; }
            .result-title { font-size: 1.8rem; margin-bottom: 20px; color: #555; }
            .score-display { font-size: 3rem; font-weight: bold; margin-bottom: 30px; }
            .stamp-box { position: relative; width: 300px; height: 150px; display: flex; align-items: center; justify-content: center; margin-bottom: 30px; }
            .stamp { font-family: "Impact", "Arial Black", sans-serif; font-size: 3.5rem; color: var(--stamp-color); border: 6px solid var(--stamp-color); border-radius: 15px; padding: 10px 20px; text-transform: uppercase; transform: rotate(-10deg); opacity: 0; background: rgba(255, 255, 255, 0.95); box-shadow: 0 0 0 4px rgba(255,255,255,0.5) inset; }
            .stamp.visible { animation: stampThud 0.4s cubic-bezier(0.1, 0.9, 0.2, 1.0) forwards; }
            @keyframes stampThud { 0% { transform: rotate(-10deg) scale(2.5); opacity: 0; } 50% { transform: rotate(-10deg) scale(0.9); opacity: 1; } 70% { transform: rotate(-10deg) scale(1.05); } 100% { transform: rotate(-10deg) scale(1); opacity: 1; } }
            
            /* 紙吹雪アニメーション (変更なし) */
            #confetti-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; overflow: hidden; }
            .confetti-piece { position: absolute; width: 10px; height: 10px; background-color: #ffd700; opacity: 1; transform-origin: center; animation: explode ease-out forwards; }
            @keyframes explode { 0% { opacity: 1; transform: translate(0, 0) scale(0.5) rotate(0deg); } 100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(1.2) rotate(var(--rot)); } }
            
        </style>
    </head>
    <body>
        
        <div id="confetti-container"></div>
        
        <div class="container">
            
            <div id="menu-screen">
                <h1 class="menu-title">英作文トレーニング</h1>
                <p style="color:#777;">練習したいモードを選んでください</p>
                
                <div class="menu-grid">
                    <div class="menu-btn-wrapper">
                        <button class="menu-btn btn-select" onclick="startGame(0)">
                            1. 空欄選択
                            <span class="menu-sub">Select Gap</span>
                        </button>
                        <div class="gj-badge" id="badge-0">GJ!!</div>
                    </div>
                    
                    <div class="menu-btn-wrapper">
                        <button class="menu-btn btn-sort" onclick="startGame(1)">
                            2. 並べ替え
                            <span class="menu-sub">Reorder</span>
                        </button>
                        <div class="gj-badge" id="badge-1">GJ!!</div>
                    </div>
                    
                    <div class="menu-btn-wrapper">
                        <button class="menu-btn btn-input" onclick="startGame(2)">
                            3. 空欄入力
                            <span class="menu-sub">Type Gap</span>
                        </button>
                        <div class="gj-badge" id="badge-2">GJ!!</div>
                    </div>
                    
                    <div class="menu-btn-wrapper">
                        <button class="menu-btn btn-full" onclick="startGame(3)">
                            4. 全文入力
                            <span class="menu-sub">Full Type</span>
                        </button>
                        <div class="gj-badge" id="badge-3">GJ!!</div>
                    </div>
                </div>
            </div>
            
            <div id="game-screen">
                <header>
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <button class="back-btn" onclick="showMenu()">Menu</button>
                        <div id="modeTitle" class="mode-badge">Mode 1</div>
                        <div style="width:60px;"></div>
                    </div>
                    
                    <div class="progress-bar-bg">
                        <div id="progressBar" class="progress-bar-fill"></div>
                    </div>
                    <div id="progressText" style="margin-top:5px; color:#999; font-size:0.8rem;">Progress: 1 / 4</div>
                </header>
                
                <div class="question-area">
                    <div id="jpText" class="jp-text">読み込み中...</div>
                    <button id="resetBtn" class="btn-reset" onclick="resetReorder()">Reset</button>
                </div>
                
                <div id="workspace"></div>
                
                <div class="feedback-msg" id="feedback"></div>
                
                <div class="action-area">
                    <button id="hintBtn" class="btn-hint" onclick="showHint()">Hint</button>
                    
                    <button id="checkBtn" class="btn-check" onclick="checkAnswer(event)">Check Answer</button>
                    <button id="nextBtn" class="btn-next" onclick="nextQuestion()">Next Question &raquo;</button>
                </div>
            </div>
            
            <div id="result-screen">
                <div class="result-title">Result</div>
                <div class="score-display" id="finalScore">Score: 0 / 4</div>
                
                <div class="stamp-box">
                    <div id="greatJobStamp" class="stamp">Great Job!!</div>
                </div>
                
                <button class="back-btn" style="padding:15px 30px; font-size:1.1rem; background-color:#777;" onclick="showMenu()">Back to Menu</button>
            </div>
            
        </div>
        
        <script>
            // --- データ ---
            // ★ここを書き換える
            const rawData = [
            { id: 1, ja: "この本はあの本とちょうど同じくらい易しい。", en: "This book is just as easy as that one." },
            { id: 2, ja: "彼はあなたほど金持ちではありません。", en: "He is not as rich as you are." },
            { id: 3, ja: "彼女は私と同じくらい多くの本を持っています。", en: "She has as many books as I do." },
            { id: 4, ja: "あなたはできるだけ速く走らなければなりません。", en: "You must run as fast as you can." },
            { id: 5, ja: "あなたのアパートの部屋は私のよりずっと広い。", en: "Your apartment is much larger than mine." }
            ];
            
            const MODES = [
            { name: "空欄選択 (Select)", theme: "theme-select", border: "theme-border-select" },
            { name: "並べ替え (Reorder)", theme: "theme-sort", border: "theme-border-sort" },
            { name: "空欄入力 (Type Gap)", theme: "theme-input", border: "theme-border-input" },
            { name: "全文入力 (Full Type)", theme: "theme-full", border: "theme-border-full" }
            ];
            
            // --- 状態管理 ---
            let currentModeIndex = 0;   
            let currentProblemIndex = 0;
            let correctCount = 0;
            let words = [];
            let currentGaps = []; 
            let completedModes = [false, false, false, false];
            
            // --- 音声 ---
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            function playSound(isCorrect) {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                osc.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                if (isCorrect) {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(660, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.4);
                } else {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.3);
                }
            }
            
            // --- 画面遷移 ---
            function showMenu() {
                document.getElementById("menu-screen").style.display = "flex";
                document.getElementById("game-screen").style.display = "none";
                document.getElementById("result-screen").style.display = "none";
                updateMenuBadges();
            }
            
            function updateMenuBadges() {
                completedModes.forEach((isEarned, index) => {
                        const badge = document.getElementById(`badge-${index}`);
                        if (isEarned) badge.classList.add("earned");
                        else badge.classList.remove("earned");
                });
            }
            
            function startGame(modeIndex) {
                currentModeIndex = modeIndex;
                currentProblemIndex = 0;
                correctCount = 0;
                document.getElementById("menu-screen").style.display = "none";
                document.getElementById("game-screen").style.display = "flex";
                document.getElementById("result-screen").style.display = "none";
                loadQuestion();
            }
            
            function showResult() {
                document.getElementById("game-screen").style.display = "none";
                document.getElementById("result-screen").style.display = "flex";
                const total = rawData.length;
                document.getElementById("finalScore").textContent = `Score: ${correctCount} / ${total}`;
                
                const percentage = (correctCount / total) * 100;
                const stamp = document.getElementById("greatJobStamp");
                stamp.classList.remove("visible");
                
                if (percentage >= 80) {
                    completedModes[currentModeIndex] = true;
                    setTimeout(() => {
                            stamp.classList.add("visible");
                            playSound(true);
                    }, 500);
                }
            }
            
            // --- 問題ロード ---
            function loadQuestion() {
                const p = rawData[currentProblemIndex];
                const mode = MODES[currentModeIndex];
                const enClean = p.en.replace(/[.,?!]/g, ""); 
                words = enClean.split(" ");
                // ★修正：単語リストを渡して、4文字以上を優先するロジックへ
                currentGaps = generateRandomGaps(words);
                
                const titleBadge = document.getElementById("modeTitle");
                titleBadge.textContent = mode.name;
                titleBadge.className = "mode-badge"; 
                titleBadge.classList.add(mode.theme);
                
                document.getElementById("progressText").textContent = `Progress: ${currentProblemIndex + 1} / ${rawData.length}`;
                document.getElementById("progressBar").style.width = `${((currentProblemIndex + 1) / rawData.length) * 100}%`;
                document.getElementById("jpText").textContent = p.ja;
                
                // ボタン類の表示リセット
                document.getElementById("checkBtn").style.display = "inline-block";
                document.getElementById("nextBtn").style.display = "none";
                
                // Resetボタン: モード1(Reorder)のときだけ表示
                document.getElementById("resetBtn").style.display = (currentModeIndex === 1) ? "inline-block" : "none";
                
                // Hintボタン: モード2(Input)のときだけ表示
                document.getElementById("hintBtn").style.display = (currentModeIndex === 2) ? "inline-block" : "none";
                
                document.getElementById("feedback").textContent = "";
                
                renderWorkspace(p, mode);
            }
            
            // ★修正：4文字以上の単語を優先して選ぶ関数に変更
            function generateRandomGaps(wordList) {
                const totalWords = wordList.length;
                let maxGaps = Math.floor(totalWords / 2);
                let minGaps = 2;
                if (totalWords < 2) minGaps = 1;
                if (maxGaps < minGaps) maxGaps = Math.min(minGaps, totalWords);
                const numGaps = Math.floor(Math.random() * (maxGaps - minGaps + 1)) + minGaps;
                
                // 単語の長さでインデックスを分ける
                const longIndices = [];
                const shortIndices = [];
                wordList.forEach((w, i) => {
                        if (w.length >= 4) {
                            longIndices.push(i);
                        } else {
                            shortIndices.push(i);
                        }
                });
                
                // それぞれシャッフル
                longIndices.sort(() => Math.random() - 0.5);
                shortIndices.sort(() => Math.random() - 0.5);
                
                const selectedGaps = new Set();
                
                // 必要な数だけ選ぶ（長い単語を優先）
                for (let i = 0; i < numGaps; i++) {
                    if (longIndices.length > 0) {
                        selectedGaps.add(longIndices.pop());
                    } else if (shortIndices.length > 0) {
                        selectedGaps.add(shortIndices.pop());
                    }
                }
                
                return Array.from(selectedGaps).sort((a,b) => a - b);
            }
            
            function getWordWidthStyle(word) {
                const estimatedWidth = Math.max(40, (word.length * 16) + 10);
                return `width: ${estimatedWidth}px;`;
            }
            
            // --- 描画ロジック ---
            function renderWorkspace(p, mode) {
                const workspace = document.getElementById("workspace");
                workspace.innerHTML = "";
                
                if (currentModeIndex === 0) {
                    // Mode 1: Select
                    let html = `<div class="interaction-area ${mode.border}">`;
                    words.forEach((w, i) => {
                            if (currentGaps.includes(i)) {
                                html += `<input type="text" class="gap-input" id="gap-${i}" readonly placeholder="?" style="${getWordWidthStyle(w)}"> `;
                            } else {
                                html += `<span>${w}</span> `;
                            }
                    });
                    html += ".</div>";
                    
                    let options = currentGaps.map(g => words[g]);
                    options.sort(() => Math.random() - 0.5);
                    
                    html += `<div class="options-area">`;
                    options.forEach(opt => {
                            // アポストロフィのエスケープ処理
                        html += `<button class="word-chip" onclick="fillFirstGap('${opt.replace(/'/g, "\\'")}')">${opt}</button>`;
                        });
                        html += `</div>`;
                        workspace.innerHTML = html;
                        setTimeout(() => {
                        currentGaps.forEach(i => {
                        const el = document.getElementById(`gap-${i}`);
                        if(el) el.onclick = function() { this.value = "?"; };
                        });
                        }, 0);
                        
                        } else if (currentModeIndex === 1) {
                        // Mode 2: Reorder
                        const answerBox = document.createElement("div");
                        answerBox.className = `interaction-area ${mode.border}`;
                        answerBox.id = "reorder-area";
                        answerBox.style.minHeight = "60px";
                        workspace.appendChild(answerBox);
                        
                        const poolBox = document.createElement("div");
                        poolBox.className = "options-area";
                        poolBox.id = "reorder-pool"; // ID追加
                        let shuffled = [...words].sort(() => Math.random() - 0.5);
                        shuffled.forEach((w, i) => {
                        const btn = document.createElement("button");
                        btn.className = "word-chip";
                        btn.textContent = w;
                        // 元の単語データを保持して、リセット時に使えるようにするのも手だが
                        // シンプルにHTML要素の移動で実装
                        btn.onclick = () => {
                        if(!btn.classList.contains("selected")) moveWordToAnswer(w, btn);
                        };
                        poolBox.appendChild(btn);
                        });
                        workspace.appendChild(poolBox);
                        
                        } else if (currentModeIndex === 2) {
                        // Mode 3: Type Gap
                        let html = `<div class="interaction-area ${mode.border}">`;
                        words.forEach((w, i) => {
                        if (currentGaps.includes(i)) {
                        // ★ エラーマークを出すために wrapper で囲む
                        html += `<span class="gap-wrapper">`;
                        html += `<input type="text" class="gap-input" id="type-gap-${i}" autocomplete="off" autocapitalize="off" style="${getWordWidthStyle(w)}">`;
                        html += `</span>`; 
                        } else {
                        html += `<span>${w}</span> `;
                        }
                        });
                        html += ".</div>";
                        workspace.innerHTML = html;
                        
                        } else if (currentModeIndex === 3) {
                        // Mode 4: Full Type
                        const input = document.createElement("input");
                        input.type = "text";
                        input.id = "full-input";
                        input.placeholder = "英文を入力...";
                        input.autocomplete = "off";
                        input.autocapitalize = "off";
                        input.onkeydown = (e) => { if(e.key === 'Enter') checkAnswer(e); };
                        
                        const area = document.createElement("div");
                        area.className = `interaction-area ${mode.border}`;
                        area.appendChild(input);
                        workspace.appendChild(area);
                        }
                        }
                        
                        // --- 各種操作関数 ---
                        
                        // ★ 並べ替えリセット
                        function resetReorder() {
                        const area = document.getElementById("reorder-area");
                        const pool = document.getElementById("reorder-pool");
                        if (!area || !pool) return;
                        
                        area.innerHTML = ""; // 解答欄クリア
                        // 選択肢ボタンの selected クラスを外す
                        const buttons = pool.querySelectorAll(".word-chip");
                        buttons.forEach(btn => btn.classList.remove("selected"));
                        }
                        
                        // ★ ヒント機能 (空欄入力用)
                        function showHint() {
                        currentGaps.forEach(i => {
                        const input = document.getElementById(`type-gap-${i}`);
                        if (input) {
                        const correctWord = words[i];
                        // 空欄、または間違っている場合にヒント入力
                        if (input.value.trim() === "" || input.value.toLowerCase() !== correctWord.toLowerCase()) {
                        input.value = correctWord.charAt(0);
                        // エラーマークがあれば消す
                        const wrapper = input.parentElement;
                        const mark = wrapper.querySelector(".error-mark");
                        if(mark) mark.remove();
                        }
                        }
                        });
                        }
                        
                        function fillFirstGap(word) {
                        for (let i of currentGaps) {
                        const el = document.getElementById(`gap-${i}`);
                        if (el && (el.value === "" || el.value === "?")) {
                        el.value = word;
                        break;
                        }
                        }
                        }
                        
                        function moveWordToAnswer(word, btn) {
                        const area = document.getElementById("reorder-area");
                        const chip = document.createElement("button");
                        chip.className = "word-chip";
                        chip.textContent = word;
                        chip.onclick = () => {
                        chip.remove();
                        btn.classList.remove("selected");
                        };
                        area.appendChild(chip);
                        btn.classList.add("selected");
                        }
                        
                        function checkAnswer(e) {
                        const p = rawData[currentProblemIndex];
                        let isCorrect = false;
                        const feedback = document.getElementById("feedback");
                        const correctStr = p.en.replace(/[.,?!]/g, "");
                        
                        // エラーマークのリセット (Mode 2)
                        document.querySelectorAll(".error-mark").forEach(el => el.remove());
                        
                        if (currentModeIndex === 0) {
                        let allCorrect = true;
                        currentGaps.forEach(i => {
                        if (document.getElementById(`gap-${i}`).value !== words[i]) allCorrect = false;
                        });
                        isCorrect = allCorrect;
                        
                        } else if (currentModeIndex === 1) {
                        const area = document.getElementById("reorder-area");
                        const userStr = Array.from(area.children).map(c => c.textContent).join(" ");
                        isCorrect = (userStr === correctStr);
                        
                        } else if (currentModeIndex === 2) {
                        let allCorrect = true;
                        currentGaps.forEach(i => {
                        const input = document.getElementById(`type-gap-${i}`);
                        const val = input.value.trim();
                        if (val !== words[i]) {
                        allCorrect = false;
                        // ★ 間違っている場所に「！」を追加
                        const wrapper = input.parentElement;
                        if (!wrapper.querySelector(".error-mark")) {
                        const mark = document.createElement("span");
                        mark.className = "error-mark";
                        mark.textContent = "!";
                        wrapper.appendChild(mark);
                        }
                        }
                        });
                        isCorrect = allCorrect;
                        
                        } else if (currentModeIndex === 3) {
                        const val = document.getElementById("full-input").value.trim().replace(/[.,?!]/g, "");
                        isCorrect = (val === correctStr);
                        }
                        
                        playSound(isCorrect);
                        
                        if (isCorrect) {
                        correctCount++;
                        feedback.textContent = "Great! 正解です！";
                        feedback.className = "feedback-msg correct-text";
                        document.getElementById("checkBtn").style.display = "none";
                        document.getElementById("hintBtn").style.display = "none"; // ヒントも隠す
                        document.getElementById("resetBtn").style.display = "none"; // リセットも隠す
                        document.getElementById("nextBtn").style.display = "inline-block";
                        
                        // 紙吹雪
                        let x = window.innerWidth / 2;
                        let y = window.innerHeight / 2;
                        if (e && e.clientX) {
                        x = e.clientX;
                        y = e.clientY;
                        } else if (e && e.target && e.target.getBoundingClientRect) {
                        const rect = e.target.getBoundingClientRect();
                        x = rect.left + rect.width / 2;
                        y = rect.top + rect.height / 2;
                        }
                        
                        fireConfetti(x, y);
                        } else {
                        feedback.textContent = "Try again... もう一度！";
                        feedback.className = "feedback-msg wrong-text";
                        }
                        }
                        
                        function nextQuestion() {
                        currentProblemIndex++;
                        if (currentProblemIndex >= rawData.length) {
                        showResult();
                        } else {
                        loadQuestion();
                        }
                        }
                        
                        // 紙吹雪 (変更なし)
                        function fireConfetti(x, y) {
                        const container = document.getElementById('confetti-container');
                        const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
                        
                        for (let i = 0; i < 80; i++) {
                        const confetti = document.createElement('div');
                        confetti.classList.add('confetti-piece');
                        confetti.style.left = x + 'px';
                        confetti.style.top = y + 'px';
                        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                        const size = Math.random() * 8 + 6;
                        confetti.style.width = size + 'px';
                        confetti.style.height = size + 'px';
                        
                        const tx = (Math.random() - 0.5) * 300; 
                        const ty = -(Math.random() * 150 + 100); 
                        const rot = Math.random() * 720 - 360;
                        
                        confetti.style.setProperty('--tx', `${tx}px`);
                        confetti.style.setProperty('--ty', `${ty}px`);
                        confetti.style.setProperty('--rot', `${rot}deg`);
                        
                        const duration = Math.random() * 0.6 + 0.6;
                        confetti.style.animationDuration = `${duration}s`;
                        
                        container.appendChild(confetti);
                        
                        setTimeout(() => {
                        confetti.remove();
                        }, duration * 1000 + 100);
                        }
                        }
                        </script>
                        
                        </body>
                        </html>